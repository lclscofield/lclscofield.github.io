<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Event Loop 中 await 的不同表现]]></title>
    <url>%2FEvent%20Loop%20%E4%B8%AD%20await%20%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A1%A8%E7%8E%B0.html</url>
    <content type="text"><![CDATA[这篇文章源于一道烂大街的头条面试题，题目主要考了 Event Loop 中 async/await 对原本的事件循环造成的影响。本来看了一些解析也没啥，结果上浏览器一跑，结果错了=-=。 很奇怪，网上这道题的解析还有一些讲解 Event Loop + async/await 的文章基本都错了，为啥呢？？ 咱来好好探究一下（原因很简单，规范变了，具体看最底下，不过本文主要讨论新规范下的具体表现）。 事先准备讲道理，关于 js 的异步执行顺序、宏任务、微任务这些，或者 async/await 这些慨念已经有非常多的文章写了。 这里就不多讨论这些东西。 不过看这篇文章前最好还是搞清楚这些基本概念，不懂的先看看这里: 图解搞懂JavaScript引擎Event Loop 讲的还比较清楚，不过没涉及到 async/await async 再看看阮老师的 es6 了解一下 async/await 主要内容先来看看题目只讨论浏览器环境，node 环境事件循环机制不同。 题目如下: 123456789101112131415161718192021222324252627async function async1() &#123; console.log( 'async1 start' ) await async2() console.log( 'async1 end' )&#125;async function async2() &#123; console.log( 'async2' )&#125;console.log( 'script start' )setTimeout( function () &#123; console.log( 'setTimeout' )&#125;, 0 )async1();new Promise( function ( resolve ) &#123; console.log( 'promise1' ) resolve();&#125; ).then( function () &#123; console.log( 'promise2' )&#125; )console.log( 'script end' ) 如果你的结果如下: 12345678script startasync1 startasync2promise1script endpromise2async1 endsetTimeout 那恭喜你，现在是错的（意思就是以前是这个结果没错=-=）。 在 76.0.3809.100（正式版本）的 chrome 中跑一下，正确结果如下: 12345678script startasync1 startasync2promise1script endasync1 endpromise2setTimeout 图片在这里 新旧结果的对比大家都知道 await 会阻塞语句的执行，在打印 async1 start 之后，开始执行函数 async2，此时进入函数内部打印出 async2，在阻塞的函数执行完之后，js 引擎会跳过这个执行上下文中后面的语句，先执行完所有的宏任务，此时相继打印出 promise1、script end。 然后呢？？分歧就来了！ 后两步旧的结果跟新的结果打印的完全相反！ 旧的结果打印 promise2、async1 end，意思就是说执行完宏任务之后先执行微任务，然后再执行被阻塞的语句。 这不就完事了呗！新的规范无非就是把这种情况的执行顺序调换了一下，所以才出现相反的结果。 no! no! no! 没有那么简单=-= 新规范下不同的表现在网上看了那么多关于 Event Loop + async/await 的文章，发现一个问题，同一套代码（细微差别）执行结果不一样。那些文章基本都是几年前的，我试了很多次，终于摸索到了问题在哪里（就是那些细微差别）。 现在我们将函数 async2 改成这样: 123456async function async2() &#123; console.log( 'async2' ) return new Promise((resolve, reject)=&gt; &#123; resolve() &#125;)&#125; 再放到浏览器里面执行一下，打印啥？ 咦？咋结果跟旧规范的结果一样呢？ 注意我们改的两行代码，有啥差别？ 好像就多了一个返回 promise。嗯，那原因就在这里了。 其实在我们添加返回之前，函数默认返回的是 undefined，现在是返回 promise。对于被 async 修饰的函数来说，最终一定是会返回一个 promise，但是结果也有点不同。 返回非 promise: 此时返回结果会被包装成一个 promise，注意，这是个新的 promise，也会直接进入微任务列表。而 await 之后的语句会被加入到这个 promise 的 resolve 也就是回调中执行。这个 promise 先于后面 promise2 所在的 promise 进入微任务，所以会先执行，结果就是打印顺序是 async1 end、promise2。 返回 promise: 此时由于本身就是返回的 promise（假设叫 p1），p1 会立即加入微任务列表，新的 promise 还是会被生成（叫 p2），await 之后的语句会被加入到 p2 的 resolve 也就是回调中。而 p2 会在 p1 的回调执行时被加入微任务，假设外面那个 promise 叫 p3，那么执行顺序为 p1、p3、p2。 所以现在就有一个简单好记的结论：被 await 阻塞的函数返回值只有为 promise 的时候，先执行微任务，然后才执行被阻塞的语句。 写在最后chrome 提交了优化 ECMAScript 的变更，就是针对 await 规范的变动。可以总结如下: await 后面不一定会创建新的微任务，取决于await 后面是立即返回还是promise。 await 执行之后不会强制创建新的微任务，而是继续执行。 以上两种修改会导致同步调用两个async函数时，执行权交换顺序会发生改变。但是会提高性能。 经过对问题的质疑、求解，还是能收获很多东西的，毕竟实践是检验真理的唯一标准=-=。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>EventLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试知识点汇总]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[收集一些前端面试所需知识点的文章。 HTTPHTTP1.0、HTTP1.1 和 HTTP2.0 的区别 - 前端 - 掘金 详细解析 HTTP 与 HTTPS 的区别 - 前端 - 掘金 HTTPS 原理详解 http 、TCP /IP 、Socket 、UDP区别 - 简书 HTTP缓存机制详解 - 前端 - 掘金 前端安全前端安全知多少 - 前端 - 掘金 8 大前端安全问题（上） - WEB前端 - 伯乐在线 JS 基础mqyqingfeng/Blog: 冴羽写博客的地方，预计写四个系列：JavaScript深入系列、JavaScript专题系列、ES6系列、React系列 stephentian/33-js-concepts: 每个 JavaScript 工程师都应懂的33个概念 @leonardomso Cookie、session和localStorage、以及sessionStorage之间的区别 - CSDN博客 Event Loop什么是 Event Loop？ - 阮一峰的网络日志 JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志 图解搞懂JavaScript引擎Event Loop - 掘金 JavaScript 异步、栈、事件循环、任务队列 - JS精读 - SegmentFault 思否 数据结构与算法在 JavaScript 中学习数据结构与算法 - 掘金 算法的时间复杂度和空间复杂度 - 前端 - 掘金 浏览器渲染浏览器渲染页面过程与页面优化 - 前端小事 - SegmentFault 思否 浏览器的渲染：过程与原理 - 前端 - 掘金 前端工程师需要明白的「浏览器渲染」 - 简书 浏览器的回流和重绘及其优化方式 - paopao学编程 - SegmentFault 思否 移动端和混合开发移动端300ms点击延迟和点击穿透 - 掘金 Hybrid 开发：JsBridge - Web和客户端双向通信 | 三水清 设计模式MVC，MVP 和 MVVM 的图示 - 阮一峰的网络日志 [面试专题]JS设计模式 - 前端进阶计划 - SegmentFault 思否 ES6 及以上ECMAScript 6 入门 - 阮一峰 ES7 Decorator 装饰者模式 | Taobao FED | 淘宝前端团队 面试官: 实现双向绑定Proxy比defineproperty优劣如何? - 掘金 VueVue面试中，经常会被问到的面试题/Vue知识点整理 - 前端开发随笔 - SegmentFault 思否 Vue2.0 生命周期和钩子函数 vue 双向数据绑定实现原理 - 前端 - 掘金 Vue.js双向绑定的实现原理 - kidney - 博客园 webpackwebpack由浅入深——（webpack基础配置） - 掘金 webpack由浅入深——（webpack优化配置） - 掘金 面试题前端面试题1 前端面试题2]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
</search>
